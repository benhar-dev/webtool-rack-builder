<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Rack Builder</title>
    <style>
      :root {
        --bg: #0b0c0f;
        --panel: #141622;
        --muted: #8b90a6;
        --text: #e8ebf2;
        --accent: #6aa9ff;
        --ring: #2b3e6b;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font: 14px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell;

        color-scheme: dark;
      }
      .wrap {
        max-width: 1100px;
        margin: 28px auto;
        padding: 0 16px;
      }
      h1 {
        font-size: 18px;
        margin: 0;
      }
      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin: 0 0 12px;
      }
      .version-pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: #0f1a32;
        color: var(--text);
        border: 1px solid #2b3e6b;
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 12px;
      }
      .version-pill.new::after {
        content: "New";
        display: inline-block;
        margin-left: 4px;
        padding: 2px 6px;
        font-size: 10px;
        color: #0b0c0f;
        background: #7af0a8;
        border-radius: 999px;
      }
      .changelog {
        margin-bottom: 12px;
      }
      .changelog-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }
      .changelog-list {
        margin-top: 8px;
      }
      .changelog .chg-title {
        color: #cfd6ee;
        font-size: 13px;
        margin: 10px 0 6px;
      }
      .changelog ul {
        margin: 0 0 6px 18px;
        padding: 0;
      }
      .changelog li {
        margin: 4px 0;
      }
      .close-btn {
        width: 28px;
        height: 28px;
        padding: 0;
        display: inline-grid;
        place-items: center;
        background: #0f1a32;
        border: 1px solid #2b3e6b;
        color: #cfd6ee;
        border-radius: 6px;
        cursor: pointer;
      }
      .grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 16px;
      }
      .card {
        background: var(--panel);
        border: 1px solid #1e2233;
        border-radius: 12px;
        padding: 14px;
      }
      .hint {
        color: var(--muted);
        font-size: 12px;
      }
      .dropzone {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 220px;
        border: 2px dashed #2b314a;
        border-radius: 12px;
        background: #101325;
        text-align: center;
        padding: 12px;
        user-select: none;
      }
      .dropzone.drag {
        border-color: var(--accent);
        background: #0e1a33;
      }
      .controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 10px;
        align-items: center;
      }

      select {
        background: #0f1220;
        color: var(--text);
        border: 1px solid #252a41;
        border-radius: 8px;
        padding: 8px 10px;
        min-width: 0;
      }

      select:focus {
        outline: none;
        border-color: #6aa9ff;
        box-shadow: 0 0 0 3px rgba(106, 169, 255, 0.25);
      }

      input[type="number"] {
        background: #0f1220;
        color: var(--text, #e8ebf2);
        border: 1px solid #252a41;
        border-radius: 6px;

        padding: 6px 12px;
        min-width: 80px;
        min-height: 36px;
        font-size: 14px;
        line-height: 1.4;

        box-sizing: border-box;
        transition: border-color 0.2s, box-shadow 0.2s;
      }

      input[type="number"]:focus {
        outline: none;
        border-color: #6aa9ff;
        box-shadow: 0 0 0 3px rgba(106, 169, 255, 0.25);
      }

      button {
        background-color: #1a2b4d;
        color: var(--text);
        border: 1px solid var(--ring);
        border-radius: 8px;
        padding: 8px 12px;
        cursor: pointer;
        transition: background-color 0.18s ease, border-color 0.18s ease,
          box-shadow 0.18s ease, opacity 0.18s ease, transform 0.12s ease;
      }

      button:hover:not(:disabled) {
        background-color: #3b61ad;
      }

      button:active:not(:disabled) {
        background-color: #3b61ad;
        transform: translateY(1px);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      canvas {
        max-width: 100%;
        background: #0b0c0f;
        border-radius: 8px;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .kv {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 6px 12px;
        font-size: 12px;
        color: #b5bad0;
      }

      /* Rack builder UI */
      .rack {
        max-height: 160px;
        margin-top: 10px;
        display: flex;
        gap: 8px;
        flex-wrap: nowrap;
        overflow-x: auto;
        overflow-y: hidden;
        padding-bottom: 6px;
        border-bottom: 1px dashed #2b314a;
      }
      .tile {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid #252a41;
        background: #0e1222;
        border-radius: 10px;
        padding: 6px;
        user-select: none;
      }
      .tile[draggable="true"] {
        cursor: grab;
      }
      .tile:active {
        cursor: grabbing;
      }
      .tile canvas {
        display: block;
        max-height: 120px;
        max-width: 240px;
      }
      .tile .tools {
        position: absolute;
        top: 4px;
        right: 4px;
        display: flex;
        gap: 4px;
        flex-direction: column;
        z-index: 2;
      }
      .tile .btn {
        width: 28px; /* fixed square buttons */
        height: 28px;
        padding: 0;
        display: inline-grid;
        place-items: center;
        background: #0f1a32;
        border: 1px solid #2b3e6b;
        color: #cfd6ee;
        border-radius: 6px;
        cursor: pointer;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.35);
      }
      .rack-ctrls {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
        margin-top: 10px;
      }

      .error {
        color: #ff7a7a;
      }
      .ok {
        color: #7af0a8;
      }
      .insert-marker {
        width: 6px;
        background: var(--accent);
        border-radius: 3px;
        margin: 0 2px;
        align-self: stretch;
        height: auto;
        min-height: 100%;
      }

      /* Favorites panel */
      .fav-toggle {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 101;
      }
      .favorites-panel {
        position: fixed;
        top: 0;
        right: 0;
        width: 260px;
        height: 100%;
        background: var(--panel);
        border-left: 1px solid #1e2233;
        padding: 12px;
        overflow-y: auto;
        transform: translateX(100%);
        transition: transform 0.2s;
        z-index: 100;
      }
      .favorites-panel.open {
        transform: translateX(0);
      }
      .fav-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }
      .fav-group {
        margin-bottom: 12px;
      }
      .fav-group-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: pointer;
      }
      .fav-items {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 6px;
      }
      .fav-item {
        position: relative;
        border: 1px solid #2b3e6b;
        background: #0f1220;
        border-radius: 6px;
        padding: 4px;
      }
      .fav-item canvas {
        display: block;
        max-width: 100%;
        height: auto;
      }
      .fav-item .name {
        margin-top: 4px;
        font-size: 12px;
      }
      .fav-item .del-btn {
        position: absolute;
        top: 4px;
        right: 4px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="header">
        <h1>Rack Builder</h1>
        <button
          id="versionBtn"
          class="version-pill"
          type="button"
          title="What's new"
        >
          v0.0.0
        </button>
      </div>

      <div id="changelogPanel" class="card changelog" hidden aria-live="polite">
        <div class="changelog-head">
          <strong>What’s New</strong>
          <button
            id="closeChangelogBtn"
            class="close-btn"
            type="button"
            aria-label="Close"
          >
            ✕
          </button>
        </div>
        <div class="hint">Latest updates and recent changes.</div>
        <div id="changelogList" class="changelog-list"></div>
      </div>

      <div class="grid">
        <div class="card">
          <div id="dropzone" class="dropzone" aria-label="Drop image here">
            <div>
              <div><strong>Drag an image here</strong></div>
              <div class="hint">
                Also supports pasting an image (Ctrl/Cmd+V). Each image is
                auto-cropped and added as a tile.
              </div>
            </div>
          </div>

          <div class="controls">
            <label
              >Margin
              <input
                id="marginInput"
                type="number"
                value="5"
                min="0"
                max="200"
                step="1"
            /></label>
            <label
              >White tolerance
              <input
                id="tolInput"
                type="number"
                value="10"
                min="0"
                max="60"
                step="1"
            /></label>
          </div>

          <div id="rack" class="rack" aria-label="Rack tiles"></div>
          <div id="status" class="hint" role="status"></div>
        </div>

        <div class="card">
          <div class="row">
            <button id="copyRackBtn" type="button" disabled>
              Copy combined to clipboard
            </button>
            <button id="downloadRackBtn" type="button" disabled>
              Download combined PNG
            </button>

            <div class="rack-ctrls">
              <label
                >Spacing
                <input
                  id="rackSpacing"
                  type="number"
                  value="0"
                  min="0"
                  max="200"
                  step="1"
              /></label>
              <label
                >Background
                <select id="rackBg">
                  <option value="transparent">transparent</option>
                  <option value="#ffffff" selected>white</option>
                  <option value="#000000">black</option>
                  <option value="#f5f7fb">light</option>
                </select>
              </label>
              <label
                >Vertical align
                <select id="rackValign">
                  <option value="top">top</option>
                  <option value="middle" selected>middle</option>
                  <option value="bottom">bottom</option>
                  <option value="baseline">baseline</option>
                </select>
              </label>
              <label
                >Scale %
                <input
                  id="rackScale"
                  type="number"
                  value="100"
                  min="1"
                  max="400"
                  step="1"
              /></label>
              <button id="clearRackBtn" type="button">Clear</button>
            </div>
          </div>
          <div class="hint" style="margin-top: 8px">Combined output</div>
      <canvas
        id="rackCanvas"
        width="0"
        height="0"
        aria-label="Combined output"
      ></canvas>
    </div>
  </div>
</div>

    <button id="favToggle" class="fav-toggle btn" type="button">⭐</button>
    <div id="favoritesPanel" class="favorites-panel" aria-label="Favorites">
      <div class="fav-head">
        <strong>Favorites</strong>
        <button id="addFavGroupBtn" type="button" class="btn">＋</button>
      </div>
      <div id="favGroups"></div>
    </div>

    <script>
      const APP_VERSION = "0.3.1";
      const CHANGELOG = [
        {
          version: "0.3.1",
          date: "2025-09-11",
          items: ["Improved drag-and-drop marker reaction and visibility."],
        },
        {
          version: "0.3.0",
          date: "2025-09-10",
          items: [
            "Added Scale % control to resize the combined output.",
            "Added button feedback.",
            "Simplified UI.",
            "Click the combined output to copy it to clipboard.",
          ],
        },
        {
          version: "0.2.0",
          date: "2025-09-09",
          items: ["Fixed scaling issues with very tall/short images."],
        },
        {
          version: "0.1.0",
          date: "2025-09-09",
          items: [
            "Converted personal tool to github friendly one page tool for sharing.",
          ],
        },
      ];

      function initChangelogUI() {
        const btn = document.getElementById("versionBtn");
        const panel = document.getElementById("changelogPanel");
        const list = document.getElementById("changelogList");
        const closeBtn = document.getElementById("closeChangelogBtn");
        const seenKey = "seen-version";

        // Set version label and "new" badge if not seen
        btn.textContent = "v" + APP_VERSION;
        const seen = localStorage.getItem(seenKey);
        if (seen !== APP_VERSION) btn.classList.add("new");

        // Render changelog list
        list.innerHTML = "";
        CHANGELOG.forEach((entry) => {
          const wrap = document.createElement("div");
          const title = document.createElement("div");
          title.className = "chg-title";
          title.textContent = `${entry.version} – ${entry.date}`;
          const ul = document.createElement("ul");
          entry.items.forEach((t) => {
            const li = document.createElement("li");
            li.textContent = t;
            ul.appendChild(li);
          });
          wrap.appendChild(title);
          wrap.appendChild(ul);
          list.appendChild(wrap);
        });

        const open = () => {
          panel.hidden = false;
          btn.classList.remove("new");
          localStorage.setItem(seenKey, APP_VERSION);
        };
        const close = () => {
          panel.hidden = true;
        };

        btn.addEventListener("click", () => (panel.hidden ? open() : close()));
        closeBtn.addEventListener("click", close);
      }
      (() => {
        "use strict";

        // ---- Auto-crop on white ----
        class AutoCropper {
          static computeBounds(src, whiteTol = 10) {
            const w = src.width,
              h = src.height;
            const c = document.createElement("canvas");
            c.width = w;
            c.height = h;
            const g = c.getContext("2d", { willReadFrequently: true });
            g.drawImage(src, 0, 0);

            let data;
            try {
              data = g.getImageData(0, 0, w, h).data;
            } catch {
              return { x: 0, y: 0, w, h, tainted: true };
            }

            const isNonWhite = (r, g, b, a) => {
              if (a < 10) return false;
              const dr = 255 - r,
                dg = 255 - g,
                db = 255 - b;
              return Math.max(dr, dg, db) > whiteTol;
            };

            let minX = w,
              minY = h,
              maxX = -1,
              maxY = -1;
            for (let y = 0; y < h; y++) {
              let rowHas = false;
              const rowStart = y * w * 4;
              for (let x = 0; x < w; x++) {
                const i = rowStart + x * 4;
                if (
                  isNonWhite(data[i], data[i + 1], data[i + 2], data[i + 3])
                ) {
                  rowHas = true;
                  if (x < minX) minX = x;
                  if (x > maxX) maxX = x;
                }
              }
              if (rowHas) {
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
              }
            }

            if (maxX < 0 || maxY < 0)
              return { x: 0, y: 0, w, h, tainted: false };
            return {
              x: minX,
              y: minY,
              w: maxX - minX + 1,
              h: maxY - minY + 1,
              tainted: false,
            };
          }

          static cropWithMargin(src, box, margin = 5) {
            const clamp = (v, lo, hi) => Math.min(Math.max(v, lo), hi);
            const sw = src.width,
              sh = src.height;
            const x = clamp(box.x - margin, 0, sw - 1);
            const y = clamp(box.y - margin, 0, sh - 1);
            const r = clamp(box.x + box.w + margin, 0, sw);
            const b = clamp(box.y + box.h + margin, 0, sh);
            const w = Math.max(1, r - x);
            const h = Math.max(1, b - y);

            const out = document.createElement("canvas");
            out.width = w;
            out.height = h;
            out.getContext("2d").drawImage(src, x, y, w, h, 0, 0, w, h);
            return out;
          }
        }

        // ---- Rack state + rendering ----
        class Rack {
          constructor(listEl, onChange, onExternalInsert) {
            this.listEl = listEl;
            this.onChange = onChange;
            this.onExternalInsert = onExternalInsert; // NEW
            this.items = [];
            this.normH = 0; // track target height for scaling
            this.drag = { fromIndex: -1, markerEl: null, srcEl: null };
            this.installDnD();
          }

          insertAt(canvas, index) {
            const id =
              crypto.randomUUID?.() || String(Date.now() + Math.random());
            const item = { id, canvas, w: canvas.width, h: canvas.height };
            this.items.splice(index, 0, item);
            this.recalcHeight();
            this.render();
            this.onChange?.();
          }

          duplicateAt(index) {
            const it = this.items[index];
            if (!it) return;
            // Clone the canvas content
            const dup = document.createElement("canvas");
            dup.width = it.w;
            dup.height = it.h;
            dup.getContext("2d").drawImage(it.canvas, 0, 0);
            this.insertAt(dup, Math.max(0, index)); // insert to the left
          }

          addCanvas(canvas) {
            const id =
              crypto.randomUUID?.() || String(Date.now() + Math.random());
            this.items.push({ id, canvas, w: canvas.width, h: canvas.height });
            this.recalcHeight();
            this.render();
            this.onChange?.();
          }
          clear() {
            this.items = [];
            this.recalcHeight();
            this.render();
            this.onChange?.();
          }
          removeById(id) {
            this.items = this.items.filter((it) => it.id !== id);
            this.recalcHeight();
            this.render();
            this.onChange?.();
          }
          getItemById(id) {
            return this.items.find((it) => it.id === id) || null;
          }
          cloneCanvasById(id) {
            const it = this.getItemById(id);
            if (!it) return null;
            const cnv = document.createElement("canvas");
            cnv.width = it.w;
            cnv.height = it.h;
            cnv.getContext("2d").drawImage(it.canvas, 0, 0);
            return cnv;
          }
          move(fromIndex, toIndex) {
            if (fromIndex === toIndex || fromIndex < 0 || toIndex < 0) return;
            const [it] = this.items.splice(fromIndex, 1);
            this.items.splice(toIndex, 0, it);
            // heights unaffected but recompute for safety
            this.recalcHeight();
            this.render();
            this.onChange?.();
          }

          recalcHeight() {
            this.normH = this.items.reduce(
              (max, it) => (it.h > max ? it.h : max),
              0
            );
          }

          render() {
            this.listEl.innerHTML = "";
            if (!this.items.length) return;
            const targetH = this.normH || 0;
            this.items.forEach((it, idx) => {
              const tile = document.createElement("div");
              tile.className = "tile";
              tile.draggable = true;
              tile.dataset.id = it.id;
              tile.dataset.index = String(idx);

              const scale = targetH && it.h ? targetH / it.h : 1;
              const w = Math.round(it.w * scale);
              const h = Math.round(it.h * scale);
              const thumb = document.createElement("canvas");
              thumb.width = w;
              thumb.height = h;
              thumb.getContext("2d").drawImage(it.canvas, 0, 0, w, h);
              tile.appendChild(thumb);

              const tools = document.createElement("div");
              tools.className = "tools";

              // Copy-left
              const copyL = document.createElement("button");
              copyL.className = "btn";
              copyL.type = "button";
              copyL.title = "Copy to left";
              copyL.textContent = "⧉";
              copyL.addEventListener("click", () => this.duplicateAt(idx));
              tools.appendChild(copyL);

              // Delete
              const del = document.createElement("button");
              del.className = "btn";
              del.type = "button";
              del.title = "Remove";
              del.textContent = "✖";
              del.addEventListener("click", () => this.removeById(it.id));
              tools.appendChild(del);

              tile.appendChild(tools);

              this.listEl.appendChild(tile);
            });
          }

          installDnD() {
            this.listEl.addEventListener("dragstart", (e) => {
              const t = e.target.closest?.(".tile");
              if (!t) return;
              this.drag.fromIndex = Number(t.dataset.index);
              this.drag.srcEl = t;
              e.dataTransfer.effectAllowed = "move";
              e.dataTransfer.setData("application/x-rack-item", t.dataset.id);
              // Align the drag image with the pointer to avoid jumpy ghost
              if (e.dataTransfer.setDragImage)
                e.dataTransfer.setDragImage(t, e.offsetX, e.offsetY);
            });

            this.listEl.addEventListener("dragover", (e) => {
              e.preventDefault();
              const dt = e.dataTransfer;
              const isExternal =
                dt &&
                (dt.types?.includes("Files") ||
                  dt.types?.includes("text/uri-list"));
              dt.dropEffect = isExternal ? "copy" : "move";

              this.ensureMarker();
              const x = e.clientX;

              const tiles = Array.from(
                this.listEl.querySelectorAll(".tile")
              ).filter((el) => el !== this.drag.srcEl);

              let placed = false;
              for (const tile of tiles) {
                const rect = tile.getBoundingClientRect();
                if (x < rect.left + rect.width / 2) {
                  this.listEl.insertBefore(this.drag.markerEl, tile);
                  placed = true;
                  break;
                }
              }
              if (!placed) {
                this.listEl.appendChild(this.drag.markerEl);
              }
            });

            this.listEl.addEventListener("drop", (e) => {
              e.preventDefault();
              const marker = this.drag.markerEl;
              if (!marker) return;

              const dt = e.dataTransfer;
              const isExternal =
                dt &&
                (dt.types?.includes("Files") ||
                  dt.types?.includes("text/uri-list"));
              const to = this.computeTargetIndex(marker);

              if (isExternal) {
                this.onExternalInsert?.(e, to); // NEW: let App handle decoding/cropping
                this.clearMarker();
                this.drag.fromIndex = -1;
                this.drag.srcEl = null;
                return;
              }

              // Internal reorder
              const from = this.drag.fromIndex;
              let insertTo = to;
              if (insertTo > from) insertTo -= 1;
              this.move(from, insertTo);

              this.clearMarker();
              this.drag.fromIndex = -1;
              this.drag.srcEl = null;
            });

            this.listEl.addEventListener("dragend", () => {
              this.clearMarker();
              this.drag.fromIndex = -1;
              this.drag.srcEl = null;
            });
            this.listEl.addEventListener("dragleave", (e) => {
              if (e.relatedTarget && this.listEl.contains(e.relatedTarget))
                return;
              // keep marker; flicker-free
            });
          }

          ensureMarker() {
            if (!this.drag.markerEl)
              (this.drag.markerEl = document.createElement("div")),
                (this.drag.markerEl.className = "insert-marker");
          }
          placeMarker(overTile, side) {
            const m = this.drag.markerEl;
            if (!m) return;
            if (side === "end" || !overTile) {
              this.listEl.appendChild(m);
              return;
            }
            if (side === "left") this.listEl.insertBefore(m, overTile);
            else this.listEl.insertBefore(m, overTile.nextSibling);
          }
          clearMarker() {
            if (this.drag.markerEl?.parentNode)
              this.drag.markerEl.parentNode.removeChild(this.drag.markerEl);
            this.drag.markerEl = null;
          }
          computeTargetIndex(marker) {
            const idx = Array.from(this.listEl.children).indexOf(marker);
            return idx < 0 ? this.items.length : idx;
          }
          buildCombined({ spacing = 0, bg = "white", valign = "middle" } = {}) {
            if (!this.items.length) return null;
            const targetH = this.normH || 0;
            const totalW =
              this.items.reduce(
                (acc, it) => acc + Math.round((it.w * targetH) / it.h),
                0
              ) +
              spacing * (this.items.length - 1);
            const out = document.createElement("canvas");
            out.width = totalW;
            out.height = targetH;
            const g = out.getContext("2d");
            if (bg !== "transparent") {
              g.fillStyle = bg;
              g.fillRect(0, 0, out.width, out.height);
            } else {
              g.clearRect(0, 0, out.width, out.height);
            }
            let x = 0;
            for (const it of this.items) {
              const w = Math.round((it.w * targetH) / it.h);
              let y = 0;
              // valign retained for future flexibility, though heights equal
              if (valign === "middle") y = Math.round((targetH - targetH) / 2);
              else if (valign === "bottom" || valign === "baseline")
                y = targetH - targetH;
              g.drawImage(it.canvas, x, y, w, targetH);
              x += w + spacing;
            }
            return out;
          }
        }
        class Favorites {
          constructor(container, app) {
            this.container = container;
            this.app = app;
            this.groups = [];
            this.load();
            this.render();
          }
          save() {
            const data = this.groups.map((g) => ({
              id: g.id,
              name: g.name,
              collapsed: g.collapsed || false,
              items: g.items.map((it) => ({
                id: it.id,
                name: it.name,
                w: it.w,
                h: it.h,
                data: it.canvas.toDataURL("image/png"),
              })),
            }));
            localStorage.setItem("autocrop-favorites", JSON.stringify(data));
          }
          load() {
            try {
              const raw = JSON.parse(
                localStorage.getItem("autocrop-favorites") || "[]"
              );
              this.groups = raw.map((g) => ({
                id: g.id,
                name: g.name,
                collapsed: g.collapsed || false,
                items: (g.items || []).map((it) => {
                  const cnv = document.createElement("canvas");
                  cnv.width = it.w;
                  cnv.height = it.h;
                  const img = new Image();
                  img.src = it.data;
                  img.onload = () =>
                    cnv.getContext("2d").drawImage(img, 0, 0);
                  return {
                    id: it.id,
                    name: it.name,
                    w: it.w,
                    h: it.h,
                    canvas: cnv,
                  };
                }),
              }));
            } catch {
              this.groups = [];
            }
          }
          addGroup(name = "Group") {
            const id = crypto.randomUUID?.() || String(Date.now() + Math.random());
            this.groups.push({ id, name, collapsed: false, items: [] });
            this.render();
            this.save();
          }
          removeGroup(id) {
            this.groups = this.groups.filter((g) => g.id !== id);
            this.render();
            this.save();
          }
          moveGroup(id, dir) {
            const idx = this.groups.findIndex((g) => g.id === id);
            const ni = idx + dir;
            if (idx < 0 || ni < 0 || ni >= this.groups.length) return;
            const [g] = this.groups.splice(idx, 1);
            this.groups.splice(ni, 0, g);
            this.render();
            this.save();
          }
          renameGroup(id, name) {
            const g = this.groups.find((x) => x.id === id);
            if (!g) return;
            g.name = name;
            this.render();
            this.save();
          }
          addItem(groupId, canvas, name = "") {
            const g = this.groups.find((x) => x.id === groupId);
            if (!g) return;
            const cnv = document.createElement("canvas");
            cnv.width = canvas.width;
            cnv.height = canvas.height;
            cnv.getContext("2d").drawImage(canvas, 0, 0);
            const id = crypto.randomUUID?.() || String(Date.now() + Math.random());
            g.items.push({ id, name, w: canvas.width, h: canvas.height, canvas: cnv });
            this.render();
            this.save();
          }
          removeItem(groupId, itemId) {
            const g = this.groups.find((x) => x.id === groupId);
            if (!g) return;
            g.items = g.items.filter((it) => it.id !== itemId);
            this.render();
            this.save();
          }
          renameItem(groupId, itemId, name) {
            const g = this.groups.find((x) => x.id === groupId);
            if (!g) return;
            const it = g.items.find((x) => x.id === itemId);
            if (!it) return;
            it.name = name;
            this.render();
            this.save();
          }
          cloneCanvas(groupId, itemId) {
            const g = this.groups.find((x) => x.id === groupId);
            if (!g) return null;
            const it = g.items.find((x) => x.id === itemId);
            if (!it) return null;
            const cnv = document.createElement("canvas");
            cnv.width = it.w;
            cnv.height = it.h;
            cnv.getContext("2d").drawImage(it.canvas, 0, 0);
            return cnv;
          }
          render() {
            this.container.innerHTML = "";
            this.groups.forEach((g) => {
              const groupEl = document.createElement("div");
              groupEl.className = "fav-group";
              groupEl.dataset.id = g.id;
              const head = document.createElement("div");
              head.className = "fav-group-header";
              const title = document.createElement("span");
              title.textContent = g.name;
              title.addEventListener("click", () => {
                const nm = prompt("Group name", g.name);
                if (nm) this.renameGroup(g.id, nm);
              });
              const btns = document.createElement("div");
              btns.style.display = "flex";
              btns.style.gap = "4px";
              const up = document.createElement("button");
              up.textContent = "↑";
              up.type = "button";
              up.className = "btn";
              up.addEventListener("click", () => this.moveGroup(g.id, -1));
              const down = document.createElement("button");
              down.textContent = "↓";
              down.type = "button";
              down.className = "btn";
              down.addEventListener("click", () => this.moveGroup(g.id, 1));
              const del = document.createElement("button");
              del.textContent = "✖";
              del.type = "button";
              del.className = "btn";
              del.addEventListener("click", () => {
                if (confirm("Delete group?")) this.removeGroup(g.id);
              });
              btns.appendChild(up);
              btns.appendChild(down);
              btns.appendChild(del);
              head.appendChild(title);
              head.appendChild(btns);
              head.addEventListener("dblclick", () => {
                g.collapsed = !g.collapsed;
                this.render();
                this.save();
              });
              groupEl.appendChild(head);
              const itemsEl = document.createElement("div");
              itemsEl.className = "fav-items";
              if (g.collapsed) itemsEl.style.display = "none";
              itemsEl.addEventListener("dragover", (e) => {
                e.preventDefault();
              });
              itemsEl.addEventListener("drop", (e) => this.handleDrop(e, g));
              g.items.forEach((it) => {
                const itemEl = document.createElement("div");
                itemEl.className = "fav-item";
                itemEl.draggable = true;
                itemEl.dataset.groupId = g.id;
                itemEl.dataset.id = it.id;
                const thumb = document.createElement("canvas");
                thumb.width = it.w;
                thumb.height = it.h;
                thumb.getContext("2d").drawImage(it.canvas, 0, 0, it.w, it.h);
                itemEl.appendChild(thumb);
                const name = document.createElement("div");
                name.className = "name";
                name.textContent = it.name || "unnamed";
                name.addEventListener("click", () => {
                  const nm = prompt("Item name", it.name || "");
                  if (nm != null) this.renameItem(g.id, it.id, nm);
                });
                itemEl.appendChild(name);
                const delBtn = document.createElement("button");
                delBtn.className = "del-btn btn";
                delBtn.type = "button";
                delBtn.textContent = "✖";
                delBtn.addEventListener("click", () =>
                  this.removeItem(g.id, it.id)
                );
                itemEl.appendChild(delBtn);
                itemEl.addEventListener("dragstart", (e) => {
                  e.dataTransfer.effectAllowed = "copy";
                  e.dataTransfer.setData(
                    "application/x-fav-item",
                    g.id + ":" + it.id
                  );
                });
                itemsEl.appendChild(itemEl);
              });
              groupEl.appendChild(itemsEl);
              this.container.appendChild(groupEl);
            });
          }
          handleDrop(e, g) {
            e.preventDefault();
            const dt = e.dataTransfer;
            const rackId = dt.getData("application/x-rack-item");
            if (rackId) {
              const cnv = this.app.rack.cloneCanvasById(rackId);
              if (cnv) this.addItem(g.id, cnv, "");
              return;
            }
            const favData = dt.getData("application/x-fav-item");
            if (favData) {
              const [gid, iid] = favData.split(":");
              const cnv = this.cloneCanvas(gid, iid);
              if (cnv) this.addItem(g.id, cnv, "");
              return;
            }
            if (dt.files && dt.files.length) {
              const file = Array.from(dt.files).find((f) =>
                f.type.startsWith("image/")
              );
              if (!file) return;
              const { tol, margin } = this.app.getCurrentCropParams();
              createImageBitmap(file)
                .then((bmp) =>
                  this.app.cropBitmapToCanvas(bmp, tol, margin)
                )
                .then((c) => this.addItem(g.id, c, ""))
                .catch((err) => console.error(err));
              return;
            }
            const url = dt.getData("text/uri-list") || dt.getData("text/plain");
            if (url && /^https?:\/\//i.test(url)) {
              const { tol, margin } = this.app.getCurrentCropParams();
              fetch(url.trim(), { mode: "cors", credentials: "omit" })
                .then((res) => {
                  if (!res.ok) throw new Error("HTTP " + res.status);
                  return res.blob();
                })
                .then((blob) => createImageBitmap(blob))
                .then((bmp) => this.app.cropBitmapToCanvas(bmp, tol, margin))
                .then((c) => this.addItem(g.id, c, ""))
                .catch((err) => console.error(err));
            }
          }
        }

        // ---- App wiring ----
        class App {
          constructor() {
            this.el = {
              dropzone: document.getElementById("dropzone"),
              marginInput: document.getElementById("marginInput"),
              tolInput: document.getElementById("tolInput"),
              status: document.getElementById("status"),
              rack: document.getElementById("rack"),
              rackSpacing: document.getElementById("rackSpacing"),
              rackBg: document.getElementById("rackBg"),
              rackValign: document.getElementById("rackValign"),
              rackScale: document.getElementById("rackScale"),
              clearRackBtn: document.getElementById("clearRackBtn"),
              rackCanvas: document.getElementById("rackCanvas"),
              copyRackBtn: document.getElementById("copyRackBtn"),
              downloadRackBtn: document.getElementById("downloadRackBtn"),
              favToggle: document.getElementById("favToggle"),
              favPanel: document.getElementById("favoritesPanel"),
              addFavGroupBtn: document.getElementById("addFavGroupBtn"),
              favGroups: document.getElementById("favGroups"),
            };

            this.sourceBitmap = null;
            this.lastObjectUrl = null;

            // this.rack = new Rack(this.el.rack, () => this.buildRack());

            this.rack = new Rack(
              this.el.rack,
              () => this.buildRack(),
              (e, index) => this.handleExternalInsert(e, index) // NEW
            );

            this.favs = new Favorites(this.el.favGroups, this);

            this.bindEvents();
            this.bindGlobalPaste();
            this.loadSettings();
            this.setStatus(
              "Ready. Drag/paste images. Tiles auto-crop and rack rebuilds.",
              "ok"
            );
          }

          // Settings
          loadSettings() {
            try {
              const s = JSON.parse(
                localStorage.getItem("autocrop-settings") || "{}"
              );
              if (s.margin != null) this.el.marginInput.value = s.margin;
              if (s.tol != null) this.el.tolInput.value = s.tol;
              if (s.rackSpacing != null)
                this.el.rackSpacing.value = s.rackSpacing;
              if (s.rackBg) this.el.rackBg.value = s.rackBg;
              if (s.rackValign) this.el.rackValign.value = s.rackValign;
              if (s.rackScale != null) this.el.rackScale.value = s.rackScale;
            } catch {}
          }
          saveSettings() {
            const s = {
              margin: this.el.marginInput.value,
              tol: this.el.tolInput.value,
              rackSpacing: this.el.rackSpacing.value,
              rackBg: this.el.rackBg.value,
              rackValign: this.el.rackValign.value,
              rackScale: this.el.rackScale.value,
            };
            localStorage.setItem("autocrop-settings", JSON.stringify(s));
          }

          // Events
          bindEvents() {
            const dz = this.el.dropzone;
            ["dragenter", "dragover"].forEach((evt) =>
              dz.addEventListener(evt, (e) => {
                e.preventDefault();
                dz.classList.add("drag");
              })
            );
            ["dragleave", "drop"].forEach((evt) =>
              dz.addEventListener(evt, (e) => {
                e.preventDefault();
                dz.classList.remove("drag");
              })
            );
            dz.addEventListener("drop", (e) => this.handleDrop(e));

            this.el.marginInput.addEventListener("change", () => {
              this.saveSettings();
              this.setStatus("Margin updated. New images will use it.", "ok");
            });
            this.el.tolInput.addEventListener("change", () => {
              this.saveSettings();
              this.setStatus(
                "Tolerance updated. New images will use it.",
                "ok"
              );
            });

            this.el.rackSpacing.addEventListener("change", () => {
              this.saveSettings();
              this.buildRack();
            });
            this.el.rackBg.addEventListener("change", () => {
              this.saveSettings();
              this.buildRack();
            });
            this.el.rackValign.addEventListener("change", () => {
              this.saveSettings();
              this.buildRack();
            });
            this.el.rackScale.addEventListener("change", () => {
              this.saveSettings();
              this.buildRack();
            });

            this.el.clearRackBtn.addEventListener("click", () => {
              this.rack.clear();
              this.updateRackButtonsState();
            });
            this.el.copyRackBtn.addEventListener("click", () =>
              this.copyCanvas(this.el.rackCanvas)
            );
            this.el.downloadRackBtn.addEventListener("click", () =>
              this.downloadCanvas(this.el.rackCanvas, "rack.png")
            );
            this.el.rackCanvas.addEventListener("click", () =>
              this.copyCanvas(this.el.rackCanvas)
            );

            this.el.favToggle.addEventListener("click", () => {
              this.el.favPanel.classList.toggle("open");
            });
            this.el.addFavGroupBtn.addEventListener("click", () => {
              const nm = prompt("Group name", "Group");
              this.favs.addGroup(nm || "Group");
            });
          }

          bindGlobalPaste() {
            window.addEventListener("paste", async (e) => {
              const items = Array.from(e.clipboardData?.items || []);
              const imgItem = items.find((i) => i.type.startsWith("image/"));
              if (!imgItem) return; // ignore URL/text paste
              e.preventDefault();
              const blob = imgItem.getAsFile();
              if (blob) {
                this.setStatus("Pasted image.", "ok");
                await this.loadFromBlob(blob, { alsoAddToRack: true });
              }
            });
          }

          // Loading
          async handleDrop(e) {
            const dt = e.dataTransfer;
            if (dt.files && dt.files.length) {
              this.loadFromFile(dt.files[0], { alsoAddToRack: true });
              return;
            }
            const url = dt.getData("text/uri-list") || dt.getData("text/plain");
            if (url && /^https?:\/\//i.test(url)) {
              // Dragged from web page. Try CORS fetch; otherwise advise to paste or save-and-drag.
              try {
                const bmp = await this.fetchImageAsBitmap(url.trim());
                await this.setSource(bmp, { alsoAddToRack: true });
                this.setStatus("Loaded via URL drag.", "ok");
                return;
              } catch (err) {
                this.setStatus(
                  "Could not read pixels from this URL (CORS). Paste the image or save and drag the file.",
                  "error"
                );
                console.error(err);
                return;
              }
            }
            this.setStatus(
              "Unsupported drop payload. Drop an image file or an image URL.",
              "error"
            );
          }

          async fetchImageAsBitmap(url) {
            const res = await fetch(url, { mode: "cors", credentials: "omit" });
            if (!res.ok) throw new Error("HTTP " + res.status);
            const blob = await res.blob();
            return createImageBitmap(blob);
          }
          async loadFromFile(file, opts = {}) {
            if (!file.type.startsWith("image/")) {
              this.setStatus("File is not an image.", "error");
              return;
            }
            this.setStatus(`Loading ${file.name}…`);
            await this.loadFromBlob(file, opts);
          }
          async loadFromBlob(blob, opts = {}) {
            if (this.lastObjectUrl) URL.revokeObjectURL(this.lastObjectUrl);
            this.lastObjectUrl = URL.createObjectURL(blob);
            try {
              const bmp = await createImageBitmap(blob);
              await this.setSource(bmp, opts);
              this.setStatus("Loaded image.", "ok");
            } catch (e) {
              this.setStatus("Failed to decode image.", "error");
              console.error(e);
            }
          }

          async setSource(bitmap, { alsoAddToRack = false } = {}) {
            this.sourceBitmap = bitmap;
            const cropped = this.autoCropCurrent(); // returns cropped canvas
            if (alsoAddToRack && cropped) {
              this.rack.addCanvas(cropped); // triggers auto build via onChange
              this.updateRackButtonsState();
            }
          }

          autoCropCurrent() {
            if (!this.sourceBitmap) return null;
            const tol = this.parseBoundedInt(this.el.tolInput.value, 0, 60, 10);
            const margin = this.parseBoundedInt(
              this.el.marginInput.value,
              0,
              200,
              5
            );

            const b = AutoCropper.computeBounds(this.sourceBitmap, tol);
            return AutoCropper.cropWithMargin(this.sourceBitmap, b, margin);
          }

          // Combined build
          buildRack() {
            const spacing = this.parseBoundedInt(
              this.el.rackSpacing.value,
              0,
              200,
              0
            );
            const bg = this.el.rackBg.value || "transparent";
            const valign = this.el.rackValign.value || "middle";
            const scalePct = this.parseBoundedInt(
              this.el.rackScale.value,
              1,
              400,
              100
            );
            const combined = this.rack.buildCombined({ spacing, bg, valign });
            if (!combined) {
              this.el.rackCanvas.width = 0;
              this.el.rackCanvas.height = 0;
              this.el.copyRackBtn.disabled = true;
              this.el.downloadRackBtn.disabled = true;
              this.setStatus("No tiles to combine.", "error");
              this.updateRackButtonsState();
              return;
            }
            let out = combined;
            if (scalePct !== 100) {
              const s = scalePct / 100;
              const scaled = document.createElement("canvas");
              scaled.width = Math.round(combined.width * s);
              scaled.height = Math.round(combined.height * s);
              scaled
                .getContext("2d")
                .drawImage(combined, 0, 0, scaled.width, scaled.height);
              out = scaled;
            }
            this.drawToCanvas(this.el.rackCanvas, out);
            this.updateRackButtonsState();
            this.el.copyRackBtn.disabled = false;
            this.el.downloadRackBtn.disabled = false;
            this.setStatus(
              `Built combined image ${out.width}×${out.height}.`,
              "ok"
            );
          }

          // Utilities
          drawToCanvas(canvas, srcCanvas) {
            canvas.width = srcCanvas.width;
            canvas.height = srcCanvas.height;
            const g = canvas.getContext("2d");
            g.clearRect(0, 0, canvas.width, canvas.height);
            g.drawImage(srcCanvas, 0, 0);
          }
          async copyCanvas(cnv) {
            try {
              const blob = await new Promise((res) =>
                cnv.toBlob(res, "image/png")
              );
              if (!blob) throw new Error("toBlob failed");
              await navigator.clipboard.write([
                new ClipboardItem({ [blob.type]: blob }),
              ]);
              this.setStatus("Copied PNG to clipboard.", "ok");
            } catch (e) {
              this.setStatus(
                "Clipboard copy failed. Your browser may block it in file://. Download instead.",
                "error"
              );
              console.error(e);
            }
          }
          downloadCanvas(cnv, filename) {
            cnv.toBlob((blob) => {
              if (!blob) return;
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = filename;
              document.body.appendChild(a);
              a.click();
              a.remove();
              setTimeout(() => URL.revokeObjectURL(url), 0);
            }, "image/png");
          }
          updateRackButtonsState() {
            const has = this.rack.items.length > 0;
            if (!has) {
              this.el.rackCanvas.width = 0;
              this.el.rackCanvas.height = 0;
              this.el.copyRackBtn.disabled = true;
              this.el.downloadRackBtn.disabled = true;
            }
            // Enable/disable clear depending on items present
            this.el.clearRackBtn.disabled = !has;
          }
          setStatus(text, kind = "hint") {
            const el = this.el.status;
            el.textContent = text;
            el.className =
              kind === "error" ? "error" : kind === "ok" ? "ok" : "hint";
          }
          parseBoundedInt(v, min, max, fallback) {
            let n = Number.parseInt(v, 10);
            if (!Number.isFinite(n)) n = fallback;
            return Math.min(Math.max(n, min), max);
          }

          getCurrentCropParams() {
            return {
              tol: this.parseBoundedInt(this.el.tolInput.value, 0, 60, 10),
              margin: this.parseBoundedInt(
                this.el.marginInput.value,
                0,
                200,
                5
              ),
            };
          }

          async cropBitmapToCanvas(bitmap, tol, margin) {
            const b = AutoCropper.computeBounds(bitmap, tol);
            if (b.tainted) throw new Error("tainted");
            return AutoCropper.cropWithMargin(bitmap, b, margin);
          }

          async handleExternalInsert(e, index) {
            const dt = e.dataTransfer;
            const { tol, margin } = this.getCurrentCropParams();

            const finish = (canvas) => {
              this.rack.insertAt(
                canvas,
                Math.max(0, Math.min(index, this.rack.items.length))
              );
              this.updateRackButtonsState(); // enables copy/download if needed
            };

            const favData = dt.getData("application/x-fav-item");
            if (favData) {
              const [gid, iid] = favData.split(":");
              const cnv = this.favs.cloneCanvas(gid, iid);
              if (cnv) {
                finish(cnv);
                this.setStatus("Inserted favorite.", "ok");
              }
              return;
            }

            // Files first
            if (dt.files && dt.files.length) {
              const file = Array.from(dt.files).find((f) =>
                f.type.startsWith("image/")
              );
              if (!file) {
                this.setStatus("Dropped file is not an image.", "error");
                return;
              }
              try {
                const bmp = await createImageBitmap(file);
                const cnv = await this.cropBitmapToCanvas(bmp, tol, margin);
                finish(cnv);
                this.setStatus("Inserted image at position.", "ok");
              } catch (err) {
                this.setStatus("Failed to decode/crop dropped file.", "error");
                console.error(err);
              }
              return;
            }

            // URL from another page
            const url = dt.getData("text/uri-list") || dt.getData("text/plain");
            if (url && /^https?:\/\//i.test(url)) {
              try {
                const res = await fetch(url.trim(), {
                  mode: "cors",
                  credentials: "omit",
                });
                if (!res.ok) throw new Error("HTTP " + res.status);
                const blob = await res.blob();
                const bmp = await createImageBitmap(blob);
                const cnv = await this.cropBitmapToCanvas(bmp, tol, margin);
                finish(cnv);
                this.setStatus("Inserted image from URL.", "ok");
              } catch (err) {
                this.setStatus(
                  "Could not read pixels from URL (CORS). Paste or save-and-drag.",
                  "error"
                );
                console.error(err);
              }
              return;
            }

            this.setStatus("Unsupported drop payload.", "error");
          }
        }

        initChangelogUI();
        const app = new App();
        app.updateRackButtonsState();
      })();
    </script>
  </body>
</html>
